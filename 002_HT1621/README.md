
* [Введение](#Введение)  
* [Выводы LCD 1621 для подключения к M031EC1AE](#Выводы-LCD-1621-для-подключения-к-STM32)  
* [Включение подсветки задняя сторона модуля](#Включение-подсветки-задняя-сторона-модуля)  
* [Основные функции кода для работы с LCD 1621](#Основные-функции-кода-для-работы-с-LCD-1621)
* [Battery levels](#Battery-levels)  
* [Print double](#Print-double) 

### Введение  
HT1621 – это LCD драйвер, способный управлять 128 элементным (32х4) индикатором. Возможность конфигурирования делает HT1620 пригодным для использования во множестве LCD устройств, включая LCD модули и системы дисплеев. Более подробно [здесь.](https://radiokot.ru/artfiles/6611/) Видеообзор про HT1621  [здесь.](https://www.youtube.com/watch?v=O1xRavRY38Y) 

### Выводы LCD 1621 для подключения к M031EC1AE 
- Vcc и GND питание модуля (LCD 1621) от 2.4V до 5V.  
- LED+ питание подсветки  модуля (LCD 1621).  
- CS  Chip Select(вход выбора микросхемы с подтягивающим резистором).  
- WR тактирующий сигнал для записи данных , также есть подтягивающий резистор.  
- Data последовательный ввод данных.  
Контроллер HT1621 работает на SPI протоколе он имеет раздельное тактирование для записи WR и чтения RD.  

### Включение подсветки задняя сторона модуля  
Включение подсветки модуля реализовано при помощи двух контактных площадок. При этом верхняя площадка запаяна, а нижняя распаяна. В этом положении подсветка модуля (LCD 1621) всегда включена. Для того чтобы начать управлять подсветкой необходимо распаять верхнюю площадку, а нижнюю запаять. Так же на тыльной стороне модуля (LCD 1621) расположен резистор R1, который управляет контрастом  модуля (LCD 1621). Для регулирования контраста  модуля (LCD 1621) необходимо заменить резистор на подстрочный резистор 10К.  

### Основные функции кода для работы с LCD 1621  

Функция передачи по SPI протоколу с использованием програмной реализации SPI:

~~~C
void wrDATA(uint8_t data, uint8_t len) {
  for (uint8_t i = 0; i < len; i++) {
    PA->DOUT &= ~(1 << WR);
    PA->DOUT = (data & 0x80) ? PA->DOUT | (1 << DATA) : PA->DOUT & ~(1 << DATA);
    // PA->DOUT &= ~(1 << WR);
    PA->DOUT |= (1 << WR);
    data = (data << 1);
  }
}
~~~  
Напоминаю что мы используем выводы микроконтроллера PA.0 (CS) ; PA.1 (WR) ; PA.2 (DATA).  
~~~C
#define CS   0
#define WR   1
#define DATA 2
~~~  

Далее пишем функцию для передачи команды:  
~~~C
void wrCMD(uint8_t CMD) {
  PA->DOUT &= ~(1 << CS);
  wrDATA(0x80, 4);
  wrDATA(CMD, 8);
  PA->DOUT |= (1 << CS);
}
~~~

|Operation         |    Mode     | ID    |
|:----------------:|:-----------:|:-----:|
|Read              |Data         | 110   |
|Write             |Data         | 101   |
|Read-Modify-WRITE |Data         | 101   |
|Command           |Command      | 100   |  

 Функция инициализации дисплея:  
 ~~~C
void config(void) {
  wrCMD(BIAS);
  wrCMD(RC256);
  wrCMD(SYSDIS);
  wrCMD(WDTDIS1);
  wrCMD(SYSEN);
  wrCMD(LCDON);
}
 ~~~  
 Функциюя для передачи данных:  
 ~~~C
void wrone(uint8_t addr, uint8_t sdata) {
  addr <<= 2;
  PA->DOUT &= ~(1 << CS);
  wrDATA(0xa0, 3);
  wrDATA(addr, 6);
  wrDATA(sdata, 8);
  PA->DOUT |= (1 << CS);
}
 ~~~  
